/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.legacymoddingmc.mappinggenerator;

import com.gtnewhorizons.retrofuturagradle.IMinecraftyExtension;
import com.gtnewhorizons.retrofuturagradle.MinecraftExtension;
import com.gtnewhorizons.retrofuturagradle.mcp.PatchSourcesTask;
import com.gtnewhorizons.retrofuturagradle.mcp.RemapSourceJarTask;
import com.gtnewhorizons.retrofuturagradle.minecraft.MinecraftTasks;
import com.gtnewhorizons.retrofuturagradle.shadow.org.apache.commons.io.FileUtils;
import io.legacymoddingmc.mappinggenerator.source.MCPSource;
import io.legacymoddingmc.mappinggenerator.source.YarnSource;
import lombok.val;
import org.gradle.api.JavaVersion;
import org.gradle.api.Project;
import org.gradle.api.Plugin;
import org.gradle.api.plugins.JavaPluginExtension;
import org.gradle.api.tasks.Copy;
import org.gradle.api.tasks.SourceSet;
import org.gradle.api.tasks.SourceSetContainer;
import org.gradle.api.tasks.TaskProvider;
import org.gradle.api.tasks.compile.JavaCompile;

import java.io.File;

/**
 * A simple 'hello world' plugin.
 */
public class MappingGeneratorPlugin implements Plugin<Project> {
    public void apply(Project project) {
        File outFile = new File(project.getBuildDir(), "extra-mappings/parameters.csv");

        TaskProvider<?> taskPreGenerateExtraMappings = project.getTasks().register("preGenerateExtraMappings", task -> {
            task.doLast(s -> {
                boolean doIWantToRun = true;
                if(doIWantToRun) {
                    RemapSourceJarTask taskRemapDecompiledJar = (RemapSourceJarTask)project.getTasks().getByName("remapDecompiledJar");
                    File remappedJar = taskRemapDecompiledJar.getOutputJar().get().getAsFile();
                    if(remappedJar.isFile()) {
                        System.out.println("Deleting " + remappedJar.getName() + " to force the decompilation chain to re-run!");
                        remappedJar.delete();
                    }
                } else {
                    project.getTasks().getByName("generateExtraMappings").setEnabled(false);
                }
            });
        });
        project.getTasks().getByName("mergeVanillaSidedJars").dependsOn(taskPreGenerateExtraMappings);
        // We want to analyze the Forge-patched Minecraft jar, but it only exists while RFG's deobfuscation task chain
        // is running! So, we must force RFG to run decompilation in order to access it.

        TaskProvider<?> taskGenerateExtraMappings = project.getTasks().register("generateExtraMappings", task -> {
            task.doLast(s -> {
                System.out.println("Running generateExtraMappings!");
                MappingGenerator generator = new MappingGenerator(project);
                generator.addSource(new MCPSource("1.7.10", "stable_12", MCPSource.Type.METHOD_COMMENTS));
                generator.addSource(new MCPSource("1.8.9", "stable_22", MCPSource.Type.PARAMETERS));
                generator.addSource(new MCPSource("1.12", "stable_39", MCPSource.Type.PARAMETERS));
                generator.addSource(new YarnSource("1.7.10+latest"));
                generator.generateExtraParameters(outFile);
            });
            task.dependsOn("downloadVanillaJars", "patchDecompiledJar");
        });
        project.getTasks().getByName("remapDecompiledJar").dependsOn(taskGenerateExtraMappings);

        val decompressedSourcesLocation = FileUtils.getFile(project.getBuildDir(), "mapping_generator", "src");
        val taskDecompressDecompiledSources = project.getTasks()
                .register("decompressSrgSources", Copy.class, task -> {
                    PatchSourcesTask taskPatchDecompiledJar = (PatchSourcesTask)project.getTasks().getByName("patchDecompiledJar");
                    task.dependsOn(taskPatchDecompiledJar);
                    task.from(
                            project.zipTree(taskPatchDecompiledJar.getOutputJar()),
                            subset -> { subset.include("**/*.java"); });
                    task.into(new File(decompressedSourcesLocation, "java"));
                });
        project.getTasks().getByName("generateExtraMappings").dependsOn(taskDecompressDecompiledSources);


        val patchedConfiguration = project.getConfigurations().getByName("patchedMinecraft");

        final SourceSetContainer sourceSets = project.getExtensions().getByType(SourceSetContainer.class);
        final JavaPluginExtension javaExt = project.getExtensions().getByType(JavaPluginExtension.class);

        MinecraftTasks mcTasks = (MinecraftTasks)project.getExtensions().getByName("minecraftTasks");

        val srgMcSources = sourceSets.create("srgMc", sourceSet -> {
            sourceSet.setCompileClasspath(patchedConfiguration.plus(mcTasks.getLwjgl2Configuration()));
            sourceSet.setRuntimeClasspath(patchedConfiguration);
            sourceSet.java(
                    java -> java.setSrcDirs(
                            project.files(new File(decompressedSourcesLocation, "java"))
                                    .builtBy(taskDecompressDecompiledSources)));
        });

        /*final SourceSet mainSet = sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
        final SourceSet testSet = sourceSets.getByName(SourceSet.TEST_SOURCE_SET_NAME);
        final SourceSet apiSet = javaExt.getSourceSets().create("api", set -> {
            set.setCompileClasspath(patchedConfiguration.plus(unpatchedMcSources.getOutput()));
            set.setRuntimeClasspath(patchedConfiguration);
        });
        mainSet.setCompileClasspath(mainSet.getCompileClasspath().plus(apiSet.getOutput()));
        mainSet.setRuntimeClasspath(mainSet.getRuntimeClasspath().plus(apiSet.getOutput()));
        testSet.setCompileClasspath(testSet.getCompileClasspath().plus(apiSet.getOutput()));
        testSet.setRuntimeClasspath(testSet.getRuntimeClasspath().plus(apiSet.getOutput()));

        project.getConfigurations().getByName(apiSet.getCompileClasspathConfigurationName())
                .extendsFrom(project.getConfigurations().getByName(mainSet.getCompileClasspathConfigurationName()));*/

        val taskBuildSrgMc = project.getTasks()
                .named(srgMcSources.getCompileJavaTaskName(), JavaCompile.class, task -> {
                    task.dependsOn(taskDecompressDecompiledSources);
                    configureMcJavaCompilation(task, (MinecraftExtension)project.getExtensions().getByName("minecraft"));
                });
        project.getTasks().named(srgMcSources.getProcessResourcesTaskName())
                .configure(task -> task.dependsOn(taskDecompressDecompiledSources));
        project.getTasks().getByName("generateExtraMappings").dependsOn(taskBuildSrgMc);


        IMinecraftyExtension minecraft = (IMinecraftyExtension)project.getExtensions().getByName("minecraft");
        minecraft.getExtraParamsCsvs().from(outFile);
    }

    private static void configureMcJavaCompilation(JavaCompile task, MinecraftExtension mcExt) {
        task.getModularity().getInferModulePath().set(false);
        task.getOptions().setEncoding("UTF-8");
        task.getOptions().setFork(true);
        task.getOptions().setWarnings(false);
        task.setSourceCompatibility(JavaVersion.VERSION_1_8.toString());
        task.setTargetCompatibility(JavaVersion.VERSION_1_8.toString());
        task.getJavaCompiler().set(mcExt.getToolchainCompiler());
    }
}
