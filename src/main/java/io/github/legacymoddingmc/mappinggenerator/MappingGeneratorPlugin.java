/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.github.legacymoddingmc.mappinggenerator;

import com.gtnewhorizons.retrofuturagradle.IMinecraftyExtension;
import com.gtnewhorizons.retrofuturagradle.mcp.RemapSourceJarTask;
import io.github.legacymoddingmc.mappinggenerator.source.CSVSource;
import io.github.legacymoddingmc.mappinggenerator.source.MCPSource;
import io.github.legacymoddingmc.mappinggenerator.source.MappingSourceFactory;
import io.github.legacymoddingmc.mappinggenerator.source.YarnSource;
import lombok.val;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.tasks.TaskProvider;

import java.io.File;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * A simple 'hello world' plugin.
 */
public class MappingGeneratorPlugin implements Plugin<Project> {

    public void apply(Project project) {
        MappingGenerator generator = new MappingGenerator(project);

        val ext = project.getExtensions().create("mappingGenerator", MappingGeneratorExtension.class);
        ext.getSources().convention(Arrays.asList(DefaultSources.DEFAULT_SOURCES).stream().map(a -> Arrays.asList(a)).collect(Collectors.toList()));

        registerDefaultSources();

        TaskProvider<?> taskPreGenerateExtraMappings = project.getTasks().register("preGenerateExtraMappings", task -> {
            task.doLast(s -> {
                for(List<String> mappingSourceSpec : ext.getSources().get()) {
                    generator.addSource(MappingSourceFactory.fromSpec(mappingSourceSpec));
                }
                if(generator.shouldRun()) {
                    RemapSourceJarTask taskRemapDecompiledJar = (RemapSourceJarTask)project.getTasks().getByName("remapDecompiledJar");
                    File remappedJar = taskRemapDecompiledJar.getOutputJar().get().getAsFile();
                    if(remappedJar.isFile()) {
                        System.out.println("Deleting " + remappedJar.getName() + " to force the decompilation chain to re-run");
                        remappedJar.delete();
                    }
                } else {
                    project.getTasks().getByName("generateExtraMappings").setEnabled(false);
                }
            });
        });
        project.getTasks().getByName("mergeVanillaSidedJars").dependsOn(taskPreGenerateExtraMappings);
        // We want to analyze the Forge-patched Minecraft jar, but it only exists while RFG's deobfuscation task chain
        // is running! So, we must force RFG to run decompilation in order to access it.

        TaskProvider<?> taskGenerateExtraMappings = project.getTasks().register("generateExtraMappings", task -> {
            task.doLast(s -> {
                generator.generateExtraParameters();
            });
            task.dependsOn("downloadVanillaJars", "patchDecompiledJar");
        });
        project.getTasks().getByName("remapDecompiledJar").dependsOn(taskGenerateExtraMappings);

        IMinecraftyExtension minecraft = (IMinecraftyExtension)project.getExtensions().getByName("minecraft");
        minecraft.getExtraParamsCsvs().from(generator.getOutFile());
    }

    private void registerDefaultSources() {
        MappingSourceFactory.register("mcp", MCPSource::fromSpec);
        MappingSourceFactory.register("yarn", YarnSource::fromSpec);
        MappingSourceFactory.register("csv", CSVSource::fromSpec);
    }
}
